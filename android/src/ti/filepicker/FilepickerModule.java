/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package ti.filepicker;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.Environment;
import android.provider.MediaStore;

import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.TiFileProxy;
import org.appcelerator.titanium.io.TiBaseFile;
import org.appcelerator.titanium.io.TiFileFactory;
import org.appcelerator.titanium.util.TiActivityResultHandler;
import org.appcelerator.titanium.util.TiActivitySupport;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;



@Kroll.module(name="Filepicker", id="ti.filepicker")
public class FilepickerModule extends KrollModule
{

	//Accessible constants from Titanium world
	@Kroll.constant
	public static final int EXTERNAL_STORAGE = 1;

	@Kroll.constant
	public static final int CACHE_DIRECTORY = 2;

	@Kroll.constant
	public static final int DATA_DIRECTORY = 3;

	@Kroll.constant
	public static final int EXTERNAL_CACHE_DIRECTORY = 4;

	private static final String LCAT = "TiFilePicker ðŸ“² ðŸ“²";

	//Class constants
	private static final int RESULT_OK = -1;
	private static final int RESULT_CANCELED = 0;
	private static final int PICK_FILE_REQUEST = 1;

	private static Context ctx;

	private String mimeType = "*/*"; //Defaults: Select files with all mime types
	private int directory = DATA_DIRECTORY; //Defaults: Store file in app data dir

	private KrollFunction successCallback;
	private KrollFunction errorCallback;

	protected TiBaseFile tiBaseFile;

	public FilepickerModule()
	{
		super();
	}

	/**
	 * onAppCreate
	 * @param  app
	 */
	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app) {
		// Get context
		ctx = TiApplication.getInstance().getApplicationContext();
	}

	/**
	 * getFile
	 * @param  params
	 */
	@Kroll.method
	public void getFile(KrollDict params) throws Exception {

		if (init(params)) {

			TiActivitySupport activity = (TiActivitySupport) TiApplication
					.getInstance().getCurrentActivity();

			activity.launchActivityForResult(getIntent(), PICK_FILE_REQUEST,
					getActivityHandler());
		}
	}

	/**
	 * validateParams
	 * @param  params
	 * @return validation
	 */
	private boolean init(KrollDict params) {

		Boolean result = false;

		if (validateParams(params)) {
			// Get mimeType
			if (params.containsKeyAndNotNull("mimeType")) {
				this.setMimeType(params.getString("mimeType"));
			}

			if (params.containsKeyAndNotNull("directory")){
				this.setDirectory(params.getInt("directory"));
			}

			this.setSuccessCallback(params.get("success"));
			this.setErrorCallback(params.get("error"));

			result = true;
		}

		return result;
	}

	/**
	 * validateParams
	 * @param  params
	 * @return validation
	 */
	private boolean validateParams(KrollDict params) {
		Object success, error;
		Boolean validation = false;

		// Validate required callbacks
		if (params.containsKeyAndNotNull("success")
				&& params.containsKeyAndNotNull("error")) {

			success = params.get("success");
			error = params.get("error");

			if (success instanceof KrollFunction
					&& error instanceof KrollFunction) {
				validation = true;
			}
		}

		return validation;
	}

	/**
	 * getIntent
	 * @return intent
	 */
	private Intent getIntent(){

		Intent intent = new Intent();
		intent.setAction(Intent.ACTION_GET_CONTENT);
		intent.setType(mimeType);

		return intent;
	}

	/**
	 * getFilename
	 * @param  uri
	 * @return filename
	 */
	private String getFilename(Uri uri){

		String filename = null;
		String[] projection = { MediaStore.MediaColumns.DISPLAY_NAME };

		Cursor cursor = ctx.getContentResolver().query(uri,
				projection, null, null, null);

		if (cursor != null) {
			try {
				if (cursor.moveToFirst()) {
					filename = cursor.getString(0);
				}
			} finally {
				cursor.close();
			}
		}

		return filename;
	}

	/**
	 * getActivityHandler
	 * @return TiActivityResultHandler
	 */
	public TiActivityResultHandler getActivityHandler() {
		return new TiActivityResultHandler() {
			public void onError(Activity activity, int resultCode,
								Exception exception) {
				throwError("Error opening activity for result");
			}

			public void onResult(Activity activity, int requestCode,
								 int resultCode, Intent intent) {

				if (requestCode == PICK_FILE_REQUEST) {

					KrollDict dict = new KrollDict();

					if (resultCode == RESULT_OK) {

						try{

							Uri uri = intent.getData();
							dict.put("file", createTiFileProxy(uri));
							successCallback.call(getKrollObject(), dict);

						}catch (FileNotFoundException e){
							throwError("Cannot create file");
						}

					}else if(resultCode == RESULT_CANCELED){

						throwError("Action canceled by user");
					}
				}
			}
		};
	}

	/**
	 * createTiFileProxy
	 * @param uri
	 * @return TiFileProxy
	 */
	protected TiFileProxy createTiFileProxy(Uri uri) throws FileNotFoundException{
		return new TiFileProxy(createTiBaseFile(uri));
	}

	/**
	 * createTiBaseFile
	 * @param uri
	 * @return tiFile
	 */
	protected TiBaseFile createTiBaseFile(Uri uri) throws FileNotFoundException {

		TiBaseFile tiFile = null;
		String filename = getFilename(uri);

		if(filename != null) {

			File directory = getDestinationDirectory();

			if(directory != null){
				try {
					InputStream inputStream = ctx.getContentResolver().openInputStream(uri);
					String nativePath = createFile(inputStream, directory, filename);

					if(nativePath != null){
						tiFile = TiFileFactory.createTitaniumFile(new String[]{nativePath}, false);
					}
				} catch (Exception e){
					throw new FileNotFoundException();
				}
			}
		}

		return tiFile;
	}

	/**
	 * getDestinationDirectory
	 * @return destinationDirectory
	 */
	protected File getDestinationDirectory(){

		File destinationDirectory = null;
		int dir = this.getDirectory();

		switch (dir){
			case EXTERNAL_STORAGE:
				//If not available returns DATA_DIRECTORY
				destinationDirectory = getExternalStorage();
				break;

			case EXTERNAL_CACHE_DIRECTORY:
				//If not available returns DATA_DIRECTORY
				destinationDirectory = getExternalCacheStorage();
				break;

			case CACHE_DIRECTORY:
				destinationDirectory = getCacheDirectory();
				break;

			case DATA_DIRECTORY:
			default:
				destinationDirectory = getDataDirectory();
				break;
		}

		return destinationDirectory;
	}

	/**
	 * getDataDirectory
	 * @return File
	 */
	protected File getDataDirectory(){
		return ctx.getFilesDir();
	}

	/**
	 * getCacheDirectory
	 * @return File
	 */
	protected File getCacheDirectory(){
		return ctx.getCacheDir();
	}

	/**
	 * getExternalStorage
	 * @return directory
	 */
	protected File getExternalStorage(){
		File directory = ctx.getFilesDir();

		if (isExternalStorageWritable()) {
			directory = ctx.getExternalFilesDir(null);
		}

		return directory;
	}

	/**
	 * getExternalCacheStorage
	 * @return directory
	 */
	protected File getExternalCacheStorage(){
		File directory = getCacheDirectory();

		if (isExternalStorageWritable()) {
			directory = ctx.getExternalCacheDir();
		}

		return directory;
	}

	/**
	 * isExternalStorageWritable
	 * @return isWritable
	 */
	public boolean isExternalStorageWritable() {

		Boolean isWritable = false;
		String state = Environment.getExternalStorageState();

		if (Environment.MEDIA_MOUNTED.equals(state)) {
			isWritable = true;
		}

		return isWritable;
	}

	/**
	 * createFile
	 * @param inputStream
	 * @param filename
	 * @return nativePath
	 */
	public String createFile(InputStream inputStream, File directory, String filename) throws Exception {

		String nativePath = null;

		try {
			nativePath = createFileOnStorage(inputStream,
					directory.getAbsolutePath(), filename);
		} catch (Exception e) {
			throw new Exception();
		}

		return nativePath;
	}

	/**
	 * createFileOnStorage
	 * @param inputStream
	 * @param directory
	 * @param filename
	 * @return path
	 */
	public String createFileOnStorage(InputStream inputStream,
									  String directory, String filename) throws Exception {

		String path = directory + "/" + filename;

		if (stream2file(inputStream, path)) {
			return path;
		} else {
			throw new Exception();
		}
	}

	/**
	 * stream2file
	 * @param  inputStream
	 * @param path
	 * @return filename
	 */
	public boolean stream2file(InputStream inputStream, String path)
			throws Exception {

		boolean result = false;
		int bufferSize = 1024; // chunk size
		byte[] buffer = new byte[bufferSize];
		int len = 0;
		OutputStream outputStream = new BufferedOutputStream(
				new FileOutputStream(path));

		try {
			while ((len = inputStream.read(buffer)) != -1) {
				outputStream.write(buffer, 0, len);
			}
			outputStream.close();
		} catch (IOException e) {
			throw new Exception();
		}

		if (outputStream != null) {
			result = true;
		}

		return result;
	}

	/**
	 * throwError
	 * @param  message
	 * @return filename
	 */
	private void throwError(String message) {

		KrollDict dict = new KrollDict();

		dict.put("message", message);

		errorCallback.call(getKrollObject(), dict);
	}

	/**
	 * setMimeType
	 * @param mimeType
	 */
	private void setMimeType(String mimeType){
		this.mimeType = mimeType;
	}

	/**
	 * getMimeType
	 * @return mimeType
	 */
	private String getMimeType(){
		return this.mimeType;
	}

	/**
	 * setDirectory
	 * @param directory
	 */
	private void setDirectory(int directory){
		this.directory = directory;
	}

	/**
	 * getDirectory
	 * @return directory
	 */
	private int getDirectory(){
		return this.directory;
	}

	/**
	 * setSuccessCallback
	 * @param success
	 */
	private void setSuccessCallback(Object success){
		this.successCallback = (KrollFunction)success;
	}

	/**
	 * getSuccessCallback
	 * @return successCallback
	 */
	private KrollFunction getSuccessCallback(){
		return this.successCallback;
	}

	/**
	 * setErrorCallback
	 * @param error
	 */
	private void setErrorCallback(Object error){
		this.errorCallback = (KrollFunction)error;
	}

	/**
	 * getErrorCallback
	 * @return errorCallback
	 */
	private KrollFunction getErrorCallback(){
		return this.errorCallback;
	}

}
